"""
Autogenerated file - DO NOT EDIT
If you spot a bug, please report it on the mailing list and/or change the generator.
"""

import attr
from nipype.interfaces.base import (
    Directory,
    File,
    InputMultiPath,
    OutputMultiPath,
    traits,
)
from pydra import ShellCommandTask
from pydra.engine.specs import SpecInfo, ShellSpec


class compareTractInclusion:
    """
    title: Compare Tracts
    category: Diffusion.GTRACT
    description: This program will halt with a status code indicating whether a test tract is nearly enough included in a standard tract in the sense that every fiber in the test tract has a low enough sum of squares distance to some fiber in the standard tract modulo spline resampling of every fiber to a fixed number of points.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "testFiber",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--testFiber %s",
                    "help_string": "Required: test fiber tract file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "standardFiber",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--standardFiber %s",
                    "help_string": "Required: standard fiber tract file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "closeness",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--closeness %f",
                    "help_string": "Closeness of every test fiber to some fiber in the standard tract, computed as a sum of squares of spatial differences of standard points",
                },
            ),
        ),
        (
            "numberOfPoints",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfPoints %d",
                    "help_string": "Number of points in comparison fiber pairs",
                },
            ),
        ),
        (
            "testForBijection",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--testForBijection ",
                    "help_string": "Flag to apply the closeness criterion both ways",
                },
            ),
        ),
        (
            "testForFiberCardinality",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--testForFiberCardinality ",
                    "help_string": "Flag to require the same number of fibers in both tracts",
                },
            ),
        ),
        (
            "writeXMLPolyDataFile",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--writeXMLPolyDataFile ",
                    "help_string": "Flag to make use of XML files when reading and writing vtkPolyData.",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = []

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="compareTractInclusion",
        executable=" compareTractInclusion ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class extractNrrdVectorIndex:
    """
    title: Extract Nrrd Index
    category: Diffusion.GTRACT
    description: This program will extract a 3D image (single vector) from a vector 3D image at a given vector index.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputVolume %s",
                    "help_string": "Required: input file containing the vector that will be extracted",
                    "exists": "True",
                },
            ),
        ),
        (
            "vectorIndex",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--vectorIndex %d",
                    "help_string": "Index in the vector image to extract",
                },
            ),
        ),
        (
            "setImageOrientation",
            attr.ib(
                type=traits.Enum,
                metadata={
                    "argstr": "--setImageOrientation %s",
                    "help_string": "Sets the image orientation of the extracted vector (Axial, Coronal, Sagittal)",
                },
            ),
        ),
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputVolume %s",
                    "help_string": "Required: name of output NRRD file containing the vector image at the given index",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: name of output NRRD file containing the vector image at the given index",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="extractNrrdVectorIndex",
        executable=" extractNrrdVectorIndex ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractAnisotropyMap:
    """
    title: Anisotropy Map
    category: Diffusion.GTRACT
    description: This program will generate a scalar map of anisotropy, given a tensor representation. Anisotropy images are used for fiber tracking, but the anisotropy scalars are not defined along the path. Instead, the tensor representation is included as point data allowing all of these metrics to be computed using only the fiber tract point data. The images can be saved in any ITK supported format, but it is suggested that you use an image format that supports the definition of the image origin. This includes NRRD, NifTI, and Meta formats. These images can also be used for scalar analysis including regional anisotropy measures or VBM style analysis.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputTensorVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputTensorVolume %s",
                    "help_string": "Required: input file containing the diffusion tensor image",
                    "exists": "True",
                },
            ),
        ),
        (
            "anisotropyType",
            attr.ib(
                type=traits.Enum,
                metadata={
                    "argstr": "--anisotropyType %s",
                    "help_string": "Anisotropy Mapping Type: ADC, FA, RA, VR, AD, RD, LI",
                },
            ),
        ),
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputVolume %s",
                    "help_string": "Required: name of output NRRD file containing the selected kind of anisotropy scalar.",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: name of output NRRD file containing the selected kind of anisotropy scalar.",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractAnisotropyMap",
        executable=" gtractAnisotropyMap ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractAverageBvalues:
    """
    title: Average B-Values
    category: Diffusion.GTRACT
    description: This program will directly average together the baseline gradients (b value equals 0) within a DWI scan. This is usually used after gtractCoregBvalues.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputVolume %s",
                    "help_string": "Required: input image file name containing multiple baseline gradients to average",
                    "exists": "True",
                },
            ),
        ),
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputVolume %s",
                    "help_string": "Required: name of output NRRD file containing directly averaged baseline images",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "directionsTolerance",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--directionsTolerance %f",
                    "help_string": "Tolerance for matching identical gradient direction pairs",
                },
            ),
        ),
        (
            "averageB0only",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--averageB0only ",
                    "help_string": "Average only baseline gradients. All other gradient directions are not averaged, but retained in the outputVolume",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: name of output NRRD file containing directly averaged baseline images",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractAverageBvalues",
        executable=" gtractAverageBvalues ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractClipAnisotropy:
    """
    title: Clip Anisotropy
    category: Diffusion.GTRACT
    description: This program will zero the first and/or last slice of an anisotropy image, creating a clipped anisotropy image.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputVolume %s",
                    "help_string": "Required: input image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputVolume %s",
                    "help_string": "Required: name of output NRRD file containing the clipped anisotropy image",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "clipFirstSlice",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--clipFirstSlice ",
                    "help_string": "Clip the first slice of the anisotropy image",
                },
            ),
        ),
        (
            "clipLastSlice",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--clipLastSlice ",
                    "help_string": "Clip the last slice of the anisotropy image",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: name of output NRRD file containing the clipped anisotropy image",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractClipAnisotropy",
        executable=" gtractClipAnisotropy ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractCoRegAnatomy:
    """
    title: Coregister B0 to Anatomy B-Spline
    category: Diffusion.GTRACT
    description: This program will register a Nrrd diffusion weighted 4D vector image to a fixed anatomical image. Two registration methods are supported for alignment with anatomical images: Rigid and B-Spline. The rigid registration performs a rigid body registration with the anatomical images and should be done as well to initialize the B-Spline transform. The B-SPline transform is the deformable transform, where the user can control the amount of deformation based on the number of control points as well as the maximum distance that these points can move. The B-Spline registration places a low dimensional grid in the image, which is deformed. This allows for some susceptibility related distortions to be removed from the diffusion weighted images. In general the amount of motion in the slice selection and read-out directions direction should be kept low. The distortion is in the phase encoding direction in the images. It is recommended that skull stripped (i.e. image containing only brain with skull removed) images shoud be used for image co-registration with the B-Spline transform.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputVolume %s",
                    "help_string": "Required: input vector image file name. It is recommended that the input volume is the skull stripped baseline image of the DWI scan.",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputAnatomicalVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputAnatomicalVolume %s",
                    "help_string": "Required: input anatomical image file name. It is recommended that that the input anatomical image has been skull stripped and has the same orientation as the DWI scan.",
                    "exists": "True",
                },
            ),
        ),
        (
            "vectorIndex",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--vectorIndex %d",
                    "help_string": "Vector image index in the moving image (within the DWI) to be used for registration.",
                },
            ),
        ),
        (
            "inputRigidTransform",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputRigidTransform %s",
                    "help_string": "Required (for B-Spline type co-registration): input rigid transform file name. Used as a starting point for the anatomical B-Spline registration.",
                    "exists": "True",
                },
            ),
        ),
        (
            "outputTransformName",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputTransformName %s",
                    "help_string": "Required: filename for the  fit transform.",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "transformType",
            attr.ib(
                type=traits.Enum,
                metadata={
                    "argstr": "--transformType %s",
                    "help_string": "Transform Type: Rigid|Bspline",
                },
            ),
        ),
        (
            "numberOfIterations",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfIterations %d",
                    "help_string": "Number of iterations in the selected 3D fit",
                },
            ),
        ),
        (
            "gridSize",
            attr.ib(
                type=InputMultiPath,
                metadata={
                    "argstr": "--gridSize %s",
                    "help_string": "Number of grid subdivisions in all 3 directions",
                    "sep": ",",
                },
            ),
        ),
        (
            "borderSize",
            attr.ib(
                type=traits.Int,
                metadata={"argstr": "--borderSize %d", "help_string": "Size of border"},
            ),
        ),
        (
            "numberOfHistogramBins",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfHistogramBins %d",
                    "help_string": "Number of histogram bins",
                },
            ),
        ),
        (
            "spatialScale",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--spatialScale %d",
                    "help_string": "Scales the number of voxels in the image by this value to specify the number of voxels used in the registration",
                },
            ),
        ),
        (
            "convergence",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--convergence %f",
                    "help_string": "Convergence Factor",
                },
            ),
        ),
        (
            "gradientTolerance",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--gradientTolerance %f",
                    "help_string": "Gradient Tolerance",
                },
            ),
        ),
        (
            "maxBSplineDisplacement",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--maxBSplineDisplacement %f",
                    "help_string": " Sets the maximum allowed displacements in image physical coordinates for BSpline control grid along each axis.  A value of 0.0 indicates that the problem should be unbounded.  NOTE:  This only constrains the BSpline portion, and does not limit the displacement from the associated bulk transform.  This can lead to a substantial reduction in computation time in the BSpline optimizer.,       ",
                },
            ),
        ),
        (
            "maximumStepSize",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--maximumStepSize %f",
                    "help_string": "Maximum permitted step size to move in the selected 3D fit",
                },
            ),
        ),
        (
            "minimumStepSize",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--minimumStepSize %f",
                    "help_string": "Minimum required step size to move in the selected 3D fit without converging -- decrease this to make the fit more exacting",
                },
            ),
        ),
        (
            "translationScale",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--translationScale %f",
                    "help_string": "How much to scale up changes in position compared to unit rotational changes in radians -- decrease this to put more translation in the fit",
                },
            ),
        ),
        (
            "relaxationFactor",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--relaxationFactor %f",
                    "help_string": "Fraction of gradient from Jacobian to attempt to move in the selected 3D fit",
                },
            ),
        ),
        (
            "numberOfSamples",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfSamples %d",
                    "help_string": "The number of voxels sampled for mutual information computation.  Increase this for a slower, more careful fit. NOTE that it is suggested to use samplingPercentage instead of this option. However, if set, it overwrites the samplingPercentage option.  ",
                },
            ),
        ),
        (
            "samplingPercentage",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--samplingPercentage %f",
                    "help_string": "This is a number in (0.0,1.0] interval that shows the percentage of the input fixed image voxels that are sampled for mutual information computation.  Increase this for a slower, more careful fit. You can also limit the sampling focus with ROI masks and ROIAUTO mask generation. The default is to use approximately 5% of voxels (for backwards compatibility 5% ~= 500000/(256*256*256)). Typical values range from 1% for low detail images to 20% for high detail images.",
                },
            ),
        ),
        (
            "useMomentsAlign",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--useMomentsAlign ",
                    "help_string": "MomentsAlign assumes that the center of mass of the images represent similar structures.  Perform a MomentsAlign registration as part of the sequential registration steps.   This option MUST come first, and CAN NOT be used with either CenterOfHeadLAlign, GeometryAlign, or initialTransform file.  This family of options superceeds the use of transformType if any of them are set.",
                },
            ),
        ),
        (
            "useGeometryAlign",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--useGeometryAlign ",
                    "help_string": "GeometryAlign on assumes that the center of the voxel lattice of the images represent similar structures. Perform a GeometryCenterAlign registration as part of the sequential registration steps.   This option MUST come first, and CAN NOT be used with either MomentsAlign, CenterOfHeadAlign, or initialTransform file.  This family of options superceeds the use of transformType if any of them are set.",
                },
            ),
        ),
        (
            "useCenterOfHeadAlign",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--useCenterOfHeadAlign ",
                    "help_string": "CenterOfHeadAlign attempts to find a hemisphere full of foreground voxels from the superior direction as an estimate of where the center of a head shape would be to drive a center of mass estimate.  Perform a CenterOfHeadAlign registration as part of the sequential registration steps.   This option MUST come first, and CAN NOT be used with either MomentsAlign, GeometryAlign, or initialTransform file.  This family of options superceeds the use of transformType if any of them are set.",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputTransformName",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: filename for the  fit transform.",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractCoRegAnatomy",
        executable=" gtractCoRegAnatomy ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractCoRegAnatomyBspline:
    """
    title: Coregister B0 to Anatomy B-Spline
    category: Diffusion.GTRACT
    description: This program will register a NRRD diffusion weighted 4D vector image to a fixed anatomical image to produce a Bspline fit.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputVolume %s",
                    "help_string": "Required: input vector image file name. It is recommended that the input volume is the skull stripped baseline image of the DWI scan.",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputAnatomicalVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputAnatomicalVolume %s",
                    "help_string": "Required: input anatomical image file name. It is recommended that that the input anatomical image has been skull stripped and has the same orientation as the DWI scan.",
                    "exists": "True",
                },
            ),
        ),
        (
            "vectorIndex",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--vectorIndex %d",
                    "help_string": "Vector image index in the moving image (within the DWI) to be used for registration.",
                },
            ),
        ),
        (
            "inputRigidTransform",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputRigidTransform %s",
                    "help_string": "Required (for B-Spline type co-registration): input rigid transform file name. Used as a starting point for the anatomical B-Spline registration.",
                    "exists": "True",
                },
            ),
        ),
        (
            "outputBsplineTransform",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputBsplineTransform %s",
                    "help_string": "Required: filename for the B-Spline fit transform.",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "numberOfIterations",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfIterations %d",
                    "help_string": "Number of iterations in the selected 3D fit",
                },
            ),
        ),
        (
            "gridSize",
            attr.ib(
                type=InputMultiPath,
                metadata={
                    "argstr": "--gridSize %s",
                    "help_string": "Number of grid subdivisions in all 3 directions",
                    "sep": ",",
                },
            ),
        ),
        (
            "borderSize",
            attr.ib(
                type=traits.Int,
                metadata={"argstr": "--borderSize %d", "help_string": "Size of border"},
            ),
        ),
        (
            "numberOfHistogramBins",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfHistogramBins %d",
                    "help_string": "Number of histogram bins",
                },
            ),
        ),
        (
            "spatialScale",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--spatialScale %d",
                    "help_string": "Scales the number of voxels in the image by this value to specify the number of voxels used in the registration",
                },
            ),
        ),
        (
            "convergence",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--convergence %f",
                    "help_string": "Convergence Factor",
                },
            ),
        ),
        (
            "gradientTolerance",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--gradientTolerance %f",
                    "help_string": "Gradient Tolerance",
                },
            ),
        ),
        (
            "maxBSplineDisplacement",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--maxBSplineDisplacement %f",
                    "help_string": " Sets the maximum allowed displacements in image physical coordinates for BSpline control grid along each axis.  A value of 0.0 indicates that the problem should be unbounded.  NOTE:  This only constrains the BSpline portion, and does not limit the displacement from the associated bulk transform.  This can lead to a substantial reduction in computation time in the BSpline optimizer.,       ",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputBsplineTransform",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: filename for the B-Spline fit transform.",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractCoRegAnatomyBspline",
        executable=" gtractCoRegAnatomyBspline ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractCoRegAnatomyRigid:
    """
    title: Coregister B0 to Anatomy Rigid
    category: Diffusion.GTRACT
    description: This program will register a NRRD diffusion weighted 4D vector image to a fixed anatomical image to produce a rigid fit.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputVolume %s",
                    "help_string": "Required: input vector image file name. It is recommended that the input volume is the skull stripped baseline image of the DWI scan.",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputAnatomicalVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputAnatomicalVolume %s",
                    "help_string": "Required: input anatomical image file name. It is recommended that that the input anatomical image has been skull stripped and has the same orientation as the DWI scan.",
                    "exists": "True",
                },
            ),
        ),
        (
            "vectorIndex",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--vectorIndex %d",
                    "help_string": "Vector image index in the moving image (within the DWI) to be used for registration.",
                },
            ),
        ),
        (
            "outputRigidTransform",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputRigidTransform %s",
                    "help_string": "Required: filename for the rigid fit transform.",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "numberOfIterations",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfIterations %d",
                    "help_string": "Number of iterations in the selected 3D fit",
                },
            ),
        ),
        (
            "numberOfSamples",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfSamples %d",
                    "help_string": "The number of voxels sampled for mutual information computation.  Increase this for a slower, more careful fit. NOTE that it is suggested to use samplingPercentage instead of this option. However, if set, it overwrites the samplingPercentage option.  ",
                },
            ),
        ),
        (
            "samplingPercentage",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--samplingPercentage %f",
                    "help_string": "This is a number in (0.0,1.0] interval that shows the percentage of the input fixed image voxels that are sampled for mutual information computation.  Increase this for a slower, more careful fit. You can also limit the sampling focus with ROI masks and ROIAUTO mask generation. The default is to use approximately 5% of voxels (for backwards compatibility 5% ~= 500000/(256*256*256)). Typical values range from 1% for low detail images to 20% for high detail images.",
                },
            ),
        ),
        (
            "initialRotationAxis",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--initialRotationAxis %d",
                    "help_string": "Axis for the initial rotation angle: 0, 1, 2 mean x, y, z, respectively.",
                },
            ),
        ),
        (
            "initialRotationAngle",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--initialRotationAngle %f",
                    "help_string": "Angle to rotate about the initial rotation angle (Degrees)",
                },
            ),
        ),
        (
            "relaxationFactor",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--relaxationFactor %f",
                    "help_string": "Fraction of gradient from Jacobian to attempt to move in the selected 3D fit",
                },
            ),
        ),
        (
            "maximumStepSize",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--maximumStepSize %f",
                    "help_string": "Maximum permitted step size to move in the selected 3D fit",
                },
            ),
        ),
        (
            "minimumStepSize",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--minimumStepSize %f",
                    "help_string": "Minimum required step size to move in the selected 3D fit without converging -- decrease this to make the fit more exacting",
                },
            ),
        ),
        (
            "spatialScale",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--spatialScale %f",
                    "help_string": "How much to scale up changes in position compared to unit rotational changes in radians -- decrease this to put more translation in the fit",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputRigidTransform",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: filename for the rigid fit transform.",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractCoRegAnatomyRigid",
        executable=" gtractCoRegAnatomyRigid ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractConcatDwi:
    """
    title: Concat DWI Images
    category: Diffusion.GTRACT
    description: This program will concatenate two DTI runs together.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputVolume",
            attr.ib(
                type=InputMultiPath,
                metadata={
                    "argstr": "--inputVolume %s...",
                    "help_string": "Required: input file containing the first diffusion weighted image",
                },
            ),
        ),
        (
            "ignoreOrigins",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--ignoreOrigins ",
                    "help_string": "If image origins are different force all images to origin of first image",
                },
            ),
        ),
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputVolume %s",
                    "help_string": "Required: name of output NRRD file containing the combined diffusion weighted images.",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: name of output NRRD file containing the combined diffusion weighted images.",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractConcatDwi",
        executable=" gtractConcatDwi ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractCopyImageOrientation:
    """
    title: Copy Image Orientation
    category: Diffusion.GTRACT
    description: This program will copy the orientation from the reference image into the moving image. Currently, the registration process requires that the diffusion weighted images and the anatomical images have the same image orientation (i.e. Axial, Coronal, Sagittal). It is suggested that you copy the image orientation from the diffusion weighted images and apply this to the anatomical image. This image can be subsequently removed after the registration step is complete. We anticipate that this limitation will be removed in future versions of the registration programs.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputVolume %s",
                    "help_string": "Required: input file containing the signed short image to reorient without resampling.",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputReferenceVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputReferenceVolume %s",
                    "help_string": "Required: input file containing orietation that will be cloned.",
                    "exists": "True",
                },
            ),
        ),
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputVolume %s",
                    "help_string": "Required: name of output NRRD or Nifti file containing the reoriented image in reference image space.",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: name of output NRRD or Nifti file containing the reoriented image in reference image space.",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractCopyImageOrientation",
        executable=" gtractCopyImageOrientation ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractCoregBvalues:
    """
    title: Coregister B-Values
    category: Diffusion.GTRACT
    description: This step should be performed after converting DWI scans from DICOM to NRRD format. This program will register all gradients in a NRRD diffusion weighted 4D vector image (moving image) to a specified index in a fixed image. It also supports co-registration with a T2 weighted image or field map in the same plane as the DWI data. The fixed image for the registration should be a b0 image. A mutual information metric cost function is used for the registration because of the differences in signal intensity as a result of the diffusion gradients. The full affine allows the registration procedure to correct for eddy current distortions that may exist in the data. If the eddyCurrentCorrection is enabled, relaxationFactor (0.25) and maximumStepSize (0.1) should be adjusted.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "movingVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--movingVolume %s",
                    "help_string": "Required: input moving image file name. In order to register gradients within a scan to its first gradient, set the movingVolume and fixedVolume as the same image.",
                    "exists": "True",
                },
            ),
        ),
        (
            "fixedVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--fixedVolume %s",
                    "help_string": "Required: input fixed image file name. It is recommended that this image should either contain or be a b0 image.",
                    "exists": "True",
                },
            ),
        ),
        (
            "fixedVolumeIndex",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--fixedVolumeIndex %d",
                    "help_string": "Index in the fixed image for registration. It is recommended that this image should be a b0 image.",
                },
            ),
        ),
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputVolume %s",
                    "help_string": "Required: name of output NRRD file containing moving images individually resampled and fit to the specified fixed image index.",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "outputTransform",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputTransform %s",
                    "help_string": "Registration 3D transforms concatenated in a single output file.  There are no tools that can use this, but can be used for debugging purposes.",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "eddyCurrentCorrection",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--eddyCurrentCorrection ",
                    "help_string": "Flag to perform eddy current corection in addition to motion correction (recommended)",
                },
            ),
        ),
        (
            "numberOfIterations",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfIterations %d",
                    "help_string": "Number of iterations in each 3D fit",
                },
            ),
        ),
        (
            "numberOfSpatialSamples",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfSpatialSamples %d",
                    "help_string": "The number of voxels sampled for mutual information computation.  Increase this for a slower, more careful fit. NOTE that it is suggested to use samplingPercentage instead of this option. However, if set, it overwrites the samplingPercentage option.  ",
                },
            ),
        ),
        (
            "samplingPercentage",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--samplingPercentage %f",
                    "help_string": "This is a number in (0.0,1.0] interval that shows the percentage of the input fixed image voxels that are sampled for mutual information computation.  Increase this for a slower, more careful fit. You can also limit the sampling focus with ROI masks and ROIAUTO mask generation. The default is to use approximately 5% of voxels (for backwards compatibility 5% ~= 500000/(256*256*256)). Typical values range from 1% for low detail images to 20% for high detail images.",
                },
            ),
        ),
        (
            "relaxationFactor",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--relaxationFactor %f",
                    "help_string": "Fraction of gradient from Jacobian to attempt to move in each 3D fit step (adjust when eddyCurrentCorrection is enabled; suggested value = 0.25)",
                },
            ),
        ),
        (
            "maximumStepSize",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--maximumStepSize %f",
                    "help_string": "Maximum permitted step size to move in each 3D fit step (adjust when eddyCurrentCorrection is enabled; suggested value = 0.1)",
                },
            ),
        ),
        (
            "minimumStepSize",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--minimumStepSize %f",
                    "help_string": "Minimum required step size to move in each 3D fit step without converging -- decrease this to make the fit more exacting",
                },
            ),
        ),
        (
            "spatialScale",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--spatialScale %f",
                    "help_string": "How much to scale up changes in position compared to unit rotational changes in radians -- decrease this to put more rotation in the fit",
                },
            ),
        ),
        (
            "registerB0Only",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--registerB0Only ",
                    "help_string": "Register the B0 images only",
                },
            ),
        ),
        (
            "debugLevel",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--debugLevel %d",
                    "help_string": "Display debug messages, and produce debug intermediate results.  0=OFF, 1=Minimal, 10=Maximum debugging.",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: name of output NRRD file containing moving images individually resampled and fit to the specified fixed image index.",
                    "exists": "True",
                },
            ),
        ),
        (
            "outputTransform",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Registration 3D transforms concatenated in a single output file.  There are no tools that can use this, but can be used for debugging purposes.",
                    "exists": "True",
                },
            ),
        ),
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractCoregBvalues",
        executable=" gtractCoregBvalues ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractCostFastMarching:
    """
    title: Cost Fast Marching
    category: Diffusion.GTRACT
    description: This program will use a fast marching fiber tracking algorithm to identify fiber tracts from a tensor image. This program is the first portion of the algorithm. The user must first run gtractFastMarchingTracking to generate the actual fiber tracts.  This algorithm is roughly based on the work by G. Parker et al. from IEEE Transactions On Medical Imaging, 21(5): 505-512, 2002. An additional feature of including anisotropy into the vcl_cost function calculation is included.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris. The original code here was developed by Daisy Espino.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputTensorVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputTensorVolume %s",
                    "help_string": "Required: input tensor image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputAnisotropyVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputAnisotropyVolume %s",
                    "help_string": "Required: input anisotropy image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputStartingSeedsLabelMapVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputStartingSeedsLabelMapVolume %s",
                    "help_string": "Required: input starting seeds LabelMap image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "startingSeedsLabel",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--startingSeedsLabel %d",
                    "help_string": "Label value for Starting Seeds",
                },
            ),
        ),
        (
            "outputCostVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputCostVolume %s",
                    "help_string": "Output vcl_cost image",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "outputSpeedVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputSpeedVolume %s",
                    "help_string": "Output speed image",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "anisotropyWeight",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--anisotropyWeight %f",
                    "help_string": "Anisotropy weight used for vcl_cost function calculations",
                },
            ),
        ),
        (
            "stoppingValue",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--stoppingValue %f",
                    "help_string": "Terminiating value for vcl_cost function estimation",
                },
            ),
        ),
        (
            "seedThreshold",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--seedThreshold %f",
                    "help_string": "Anisotropy threshold used for seed selection",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputCostVolume",
            attr.ib(
                type=File,
                metadata={"help_string": "Output vcl_cost image", "exists": "True"},
            ),
        ),
        (
            "outputSpeedVolume",
            attr.ib(
                type=File,
                metadata={"help_string": "Output speed image", "exists": "True"},
            ),
        ),
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractCostFastMarching",
        executable=" gtractCostFastMarching ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractCreateGuideFiber:
    """
    title: Create Guide Fiber
    category: Diffusion.GTRACT
    description: This program will create a guide fiber by averaging fibers from a previously generated tract.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputFiber",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputFiber %s",
                    "help_string": "Required: input fiber tract file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "numberOfPoints",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfPoints %d",
                    "help_string": "Number of points in output guide fiber",
                },
            ),
        ),
        (
            "outputFiber",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputFiber %s",
                    "help_string": "Required: output guide fiber file name",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "writeXMLPolyDataFile",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--writeXMLPolyDataFile ",
                    "help_string": "Flag to make use of XML files when reading and writing vtkPolyData.",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputFiber",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: output guide fiber file name",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractCreateGuideFiber",
        executable=" gtractCreateGuideFiber ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractFastMarchingTracking:
    """
    title: Fast Marching Tracking
    category: Diffusion.GTRACT
    description: This program will use a fast marching fiber tracking algorithm to identify fiber tracts from a tensor image. This program is the second portion of the algorithm. The user must first run gtractCostFastMarching to generate the vcl_cost image. The second step of the algorithm implemented here is a gradient descent soplution from the defined ending region back to the seed points specified in gtractCostFastMarching. This algorithm is roughly based on the work by G. Parker et al. from IEEE Transactions On Medical Imaging, 21(5): 505-512, 2002. An additional feature of including anisotropy into the vcl_cost function calculation is included.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris. The original code here was developed by Daisy Espino.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputTensorVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputTensorVolume %s",
                    "help_string": "Required: input tensor image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputAnisotropyVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputAnisotropyVolume %s",
                    "help_string": "Required: input anisotropy image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputCostVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputCostVolume %s",
                    "help_string": "Required: input vcl_cost image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputStartingSeedsLabelMapVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputStartingSeedsLabelMapVolume %s",
                    "help_string": "Required: input starting seeds LabelMap image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "startingSeedsLabel",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--startingSeedsLabel %d",
                    "help_string": "Label value for Starting Seeds",
                },
            ),
        ),
        (
            "outputTract",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputTract %s",
                    "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them.",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "writeXMLPolyDataFile",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--writeXMLPolyDataFile ",
                    "help_string": "Flag to make use of the XML format for vtkPolyData fiber tracts.",
                },
            ),
        ),
        (
            "numberOfIterations",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfIterations %d",
                    "help_string": "Number of iterations used for the optimization",
                },
            ),
        ),
        (
            "seedThreshold",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--seedThreshold %f",
                    "help_string": "Anisotropy threshold used for seed selection",
                },
            ),
        ),
        (
            "trackingThreshold",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--trackingThreshold %f",
                    "help_string": "Anisotropy threshold used for fiber tracking",
                },
            ),
        ),
        (
            "costStepSize",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--costStepSize %f",
                    "help_string": "Cost image sub-voxel sampling",
                },
            ),
        ),
        (
            "maximumStepSize",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--maximumStepSize %f",
                    "help_string": "Maximum step size to move when tracking",
                },
            ),
        ),
        (
            "minimumStepSize",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--minimumStepSize %f",
                    "help_string": "Minimum step size to move when tracking",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputTract",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them.",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractFastMarchingTracking",
        executable=" gtractFastMarchingTracking ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractFiberTracking:
    """
    title: Fiber Tracking
    category: Diffusion.GTRACT
    description: This program implements four fiber tracking methods (Free, Streamline, GraphSearch, Guided). The output of the fiber tracking is vtkPolyData (i.e. Polylines) that can be loaded into Slicer3 for visualization. The poly data can be saved in either old VTK format files (.vtk) or in the new VTK XML format (.xml). The polylines contain point data that defines ther Tensor at each point along the fiber tract. This can then be used to rendered as glyphs in Slicer3 and can be used to define severeal scalar measures without referencing back to the anisotropy images. (1) Free tracking is a basic streamlines algorithm. This is a direct implementation of the method original proposed by Basser et al. The tracking follows the primarty eigenvector. The tracking begins with seed points in the starting region. Only those voxels above the specified anisotropy threshold in the starting region are used as seed points. Tracking terminates either as a result of maximum fiber length, low ansiotropy, or large curvature. This is a great way to explore your data. (2) The streamlines algorithm is a direct implementation of the method originally proposed by Basser et al. The tracking follows the primary eigenvector. The tracking begins with seed points in the starting region. Only those voxels above the specified anisotropy threshold in the starting region are used as seed points. Tracking terminates either by reaching the ending region or reaching some stopping criteria. Stopping criteria are specified using the following parameters: tracking threshold, curvature threshold, and max length. Only paths terminating in the ending region are kept in this method. The TEND algorithm proposed by Lazar et al. (Human Brain Mapping 18:306-321, 2003) has been instrumented. This can be enabled using the --useTend option while performing Streamlines tracking. This utilizes the entire diffusion tensor to deflect the incoming vector instead of simply following the primary eigenvector. The TEND parameters are set using the --tendF and --tendG options. (3) Graph Search tracking is the first step in the full GTRACT algorithm developed by Cheng et al. (NeuroImage 31(3): 1075-1085, 2006) for finding the tracks in a tensor image. This method was developed to generate fibers in a Tensor representation where crossing fibers occur. The graph search algorithm follows the primary eigenvector in non-ambigous regions and utilizes branching and a graph search algorithm in ambigous regions. Ambiguous tracking regions are defined based on two criteria: Branching Al Threshold (anisotropy values below this value and above the traching threshold) and Curvature Major Eigen (angles of the primary eigenvector direction and the current tracking direction). In regions that meet this criteria, two or three tracking paths are considered. The first is the standard primary eigenvector direction. The second is the seconadary eigenvector direction. This is based on the assumption that these regions may be prolate regions. If the Random Walk option is selected then a third direction is also considered. This direction is defined by a cone pointing from the current position to the centroid of the ending region. The interior angle of the cone is specified by the user with the Branch/Guide Angle parameter. A vector contained inside of the cone is selected at random and used as the third direction. This method can also utilize the TEND option where the primary tracking direction is that specified by the TEND method instead of the primary eigenvector. The parameter '--maximumBranchPoints' allows the tracking to have this number of branches being considered at a time. If this number of branch points is exceeded at any time, then the algorithm will revert back to a streamline alogrithm until the number of branches is reduced. This allows the user to constrain the computational complexity of the algorithm. (4) The second phase of the GTRACT algorithm is Guided Tracking. This method incorporates anatomical information about the track orientation using an initial guess of the fiber track. In the originally proposed GTRACT method, this would be created from the fibers resulting from the Graph Search tracking. However, in practice this can be created using any method and could be defined manually. To create the guide fiber the program gtractCreateGuideFiber can be used. This program will load a fiber tract that has been generated and create a centerline representation of the fiber tract (i.e. a single fiber). In this method, the fiber tracking follows the primary eigenvector direction unless it deviates from the guide fiber track by a angle greater than that specified by the '--guidedCurvatureThreshold' parameter. The user must specify the guide fiber when running this program.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta, Greg Harris and Yongqiang Zhao.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputTensorVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputTensorVolume %s",
                    "help_string": "Required (for Free, Streamline, GraphSearch, and Guided fiber tracking methods): input tensor image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputAnisotropyVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputAnisotropyVolume %s",
                    "help_string": "Required (for Free, Streamline, GraphSearch, and Guided fiber tracking methods): input anisotropy image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputStartingSeedsLabelMapVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputStartingSeedsLabelMapVolume %s",
                    "help_string": "Required (for Free, Streamline, GraphSearch, and Guided fiber tracking methods): input starting seeds LabelMap image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "startingSeedsLabel",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--startingSeedsLabel %d",
                    "help_string": "Label value for Starting Seeds (required if Label number used to create seed point in Slicer was not 1)",
                },
            ),
        ),
        (
            "inputEndingSeedsLabelMapVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputEndingSeedsLabelMapVolume %s",
                    "help_string": "Required (for Streamline, GraphSearch, and Guided fiber tracking methods): input ending seeds LabelMap image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "endingSeedsLabel",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--endingSeedsLabel %d",
                    "help_string": "Label value for Ending Seeds (required if Label number used to create seed point in Slicer was not 1)",
                },
            ),
        ),
        (
            "inputTract",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputTract %s",
                    "help_string": "Required (for Guided fiber tracking method): guide fiber in vtkPolydata file containing one tract line.",
                    "exists": "True",
                },
            ),
        ),
        (
            "outputTract",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputTract %s",
                    "help_string": "Required (for Free, Streamline, GraphSearch, and Guided fiber tracking methods): name of output vtkPolydata file containing tract lines and the point data collected along them.",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "writeXMLPolyDataFile",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--writeXMLPolyDataFile ",
                    "help_string": "Flag to make use of the XML format for vtkPolyData fiber tracts.",
                },
            ),
        ),
        (
            "trackingMethod",
            attr.ib(
                type=traits.Enum,
                metadata={
                    "argstr": "--trackingMethod %s",
                    "help_string": "Fiber tracking Filter Type: Guided|Free|Streamline|GraphSearch",
                },
            ),
        ),
        (
            "guidedCurvatureThreshold",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--guidedCurvatureThreshold %f",
                    "help_string": "Guided Curvature Threshold (Degrees)",
                },
            ),
        ),
        (
            "maximumGuideDistance",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--maximumGuideDistance %f",
                    "help_string": "Maximum distance for using the guide fiber direction",
                },
            ),
        ),
        (
            "seedThreshold",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--seedThreshold %f",
                    "help_string": "Anisotropy threshold for seed selection (recommended for Free fiber tracking)",
                },
            ),
        ),
        (
            "trackingThreshold",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--trackingThreshold %f",
                    "help_string": "Anisotropy threshold for fiber tracking (anisotropy values of the next point along the path)",
                },
            ),
        ),
        (
            "curvatureThreshold",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--curvatureThreshold %f",
                    "help_string": "Curvature threshold in degrees (recommended for Free  fiber tracking)",
                },
            ),
        ),
        (
            "branchingThreshold",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--branchingThreshold %f",
                    "help_string": "Anisotropy Branching threshold (recommended for GraphSearch fiber tracking method)",
                },
            ),
        ),
        (
            "maximumBranchPoints",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--maximumBranchPoints %d",
                    "help_string": "Maximum branch points (recommended for GraphSearch fiber tracking method)",
                },
            ),
        ),
        (
            "useRandomWalk",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--useRandomWalk ",
                    "help_string": "Flag to use random walk.",
                },
            ),
        ),
        (
            "randomSeed",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--randomSeed %d",
                    "help_string": "Random number generator seed",
                },
            ),
        ),
        (
            "branchingAngle",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--branchingAngle %f",
                    "help_string": "Branching angle in degrees (recommended for GraphSearch fiber tracking method)",
                },
            ),
        ),
        (
            "minimumLength",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--minimumLength %f",
                    "help_string": "Minimum fiber length. Helpful for filtering invalid tracts.",
                },
            ),
        ),
        (
            "maximumLength",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--maximumLength %f",
                    "help_string": "Maximum fiber length (voxels)",
                },
            ),
        ),
        (
            "stepSize",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--stepSize %f",
                    "help_string": "Fiber tracking step size",
                },
            ),
        ),
        (
            "useLoopDetection",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--useLoopDetection ",
                    "help_string": "Flag to make use of loop detection.",
                },
            ),
        ),
        (
            "useTend",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--useTend ",
                    "help_string": "Flag to make use of Tend F and Tend G parameters.",
                },
            ),
        ),
        (
            "tendF",
            attr.ib(
                type=traits.Float,
                metadata={"argstr": "--tendF %f", "help_string": "Tend F parameter"},
            ),
        ),
        (
            "tendG",
            attr.ib(
                type=traits.Float,
                metadata={"argstr": "--tendG %f", "help_string": "Tend G parameter"},
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputTract",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required (for Free, Streamline, GraphSearch, and Guided fiber tracking methods): name of output vtkPolydata file containing tract lines and the point data collected along them.",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractFiberTracking",
        executable=" gtractFiberTracking ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractFreeTracking:
    """
    title: Free Tracking
    category: Diffusion.GTRACT
    description: This program will use streamlines fiber tracking to identify fiber tracts in a tensor image. A seed region is specify for initializing the algorithm. All fibers are kept and are terminated based on the stopping criteria including anisotropy, curvature and length.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputTensorVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputTensorVolume %s",
                    "help_string": "Required: input tensor image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputAnisotropyVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputAnisotropyVolume %s",
                    "help_string": "Required: input anisotropy image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputStartingSeedsLabelMapVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputStartingSeedsLabelMapVolume %s",
                    "help_string": "Required: input starting seeds LabelMap image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "startingSeedsLabel",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--startingSeedsLabel %d",
                    "help_string": "Label value for Starting Seeds",
                },
            ),
        ),
        (
            "outputTract",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputTract %s",
                    "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them.",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "writeXMLPolyDataFile",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--writeXMLPolyDataFile ",
                    "help_string": "Flag to make use of the XML format for vtkPolyData fiber tracts.",
                },
            ),
        ),
        (
            "seedThreshold",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--seedThreshold %f",
                    "help_string": "Anisotropy threshold for seed selection",
                },
            ),
        ),
        (
            "trackingThreshold",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--trackingThreshold %f",
                    "help_string": "Anisotropy threshold for fiber tracking",
                },
            ),
        ),
        (
            "curvatureThreshold",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--curvatureThreshold %f",
                    "help_string": "Curvature threshold (Degrees)",
                },
            ),
        ),
        (
            "minimumLength",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--minimumLength %f",
                    "help_string": "Minimum fiber length. Helpful for filtering invalid tracts.",
                },
            ),
        ),
        (
            "maximumLength",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--maximumLength %f",
                    "help_string": "Maximum fiber length",
                },
            ),
        ),
        (
            "stepSize",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--stepSize %f",
                    "help_string": "Fiber tracking step size",
                },
            ),
        ),
        (
            "useLoopDetection",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--useLoopDetection ",
                    "help_string": "Flag to make use of loop detection.",
                },
            ),
        ),
        (
            "useTend",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--useTend ",
                    "help_string": "Flag to make use of Tend F and Tend G parameters.",
                },
            ),
        ),
        (
            "tendF",
            attr.ib(
                type=traits.Float,
                metadata={"argstr": "--tendF %f", "help_string": "Tend F parameter"},
            ),
        ),
        (
            "tendG",
            attr.ib(
                type=traits.Float,
                metadata={"argstr": "--tendG %f", "help_string": "Tend G parameter"},
            ),
        ),
    ]
    output_fields = [
        (
            "outputTract",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them.",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractFreeTracking",
        executable=" gtractFreeTracking ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractGraphSearchTracking:
    """
    title: Graph Search Tracking
    category: Diffusion.GTRACT
    description: This program implements the Graph Serach Tracking method proposed by Cheng et al. in NeuroImage Volume 31, Issue 3, 1 July 2006, Pages 1075-1085 for finding the tracks in a tensor image.  This method to generate fibers in a Tensor representation where crossing fibers occur.  This is defined by low anisotropy and high curvature. Both of these values are controlled by the user. In these regions, three directions for tracking are considered. This includes the primary eigenvector, secondary eigenvector, and a vector with random pertubations added pointing towards the ending region.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputTensorVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputTensorVolume %s",
                    "help_string": "Required: input tensor image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputAnisotropyVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputAnisotropyVolume %s",
                    "help_string": "Required: input anisotropy image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputStartingSeedsLabelMapVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputStartingSeedsLabelMapVolume %s",
                    "help_string": "Required: input starting seeds LabelMap image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "startingSeedsLabel",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--startingSeedsLabel %d",
                    "help_string": "Label value for Starting Seeds",
                },
            ),
        ),
        (
            "inputEndingSeedsLabelMapVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputEndingSeedsLabelMapVolume %s",
                    "help_string": "Required: input ending seeds LabelMap image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "endingSeedsLabel",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--endingSeedsLabel %d",
                    "help_string": "Label value for Ending Seeds",
                },
            ),
        ),
        (
            "outputTract",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputTract %s",
                    "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them.",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "writeXMLPolyDataFile",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--writeXMLPolyDataFile ",
                    "help_string": "Flag to make use of the XML format for vtkPolyData fiber tracts.",
                },
            ),
        ),
        (
            "seedThreshold",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--seedThreshold %f",
                    "help_string": "Anisotropy threshold for seed selection",
                },
            ),
        ),
        (
            "trackingThreshold",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--trackingThreshold %f",
                    "help_string": "Anisotropy threshold for fiber tracking",
                },
            ),
        ),
        (
            "curvatureThreshold",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--curvatureThreshold %f",
                    "help_string": "Curvature threshold (Degrees)",
                },
            ),
        ),
        (
            "branchingThreshold",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--branchingThreshold %f",
                    "help_string": "Anisotropy Branching threshold",
                },
            ),
        ),
        (
            "maximumBranchPoints",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--maximumBranchPoints %d",
                    "help_string": "Maximum branch points",
                },
            ),
        ),
        (
            "useRandomWalk",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--useRandomWalk ",
                    "help_string": "Flag to use random walk.",
                },
            ),
        ),
        (
            "randomSeed",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--randomSeed %d",
                    "help_string": "Random number generator seed",
                },
            ),
        ),
        (
            "branchingAngle",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--branchingAngle %f",
                    "help_string": "Branchging angle (Degrees)",
                },
            ),
        ),
        (
            "minimumLength",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--minimumLength %f",
                    "help_string": "Minimum fiber length. Helpful for filtering invalid tracts.",
                },
            ),
        ),
        (
            "maximumLength",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--maximumLength %f",
                    "help_string": "Maximum fiber length",
                },
            ),
        ),
        (
            "stepSize",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--stepSize %f",
                    "help_string": "Fiber tracking step size",
                },
            ),
        ),
        (
            "useLoopDetection",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--useLoopDetection ",
                    "help_string": "Flag to make use of loop detection.",
                },
            ),
        ),
        (
            "useTend",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--useTend ",
                    "help_string": "Flag to make use of Tend F and Tend G parameters.",
                },
            ),
        ),
        (
            "tendF",
            attr.ib(
                type=traits.Float,
                metadata={"argstr": "--tendF %f", "help_string": "Tend F parameter"},
            ),
        ),
        (
            "tendG",
            attr.ib(
                type=traits.Float,
                metadata={"argstr": "--tendG %f", "help_string": "Tend G parameter"},
            ),
        ),
    ]
    output_fields = [
        (
            "outputTract",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them.",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractGraphSearchTracking",
        executable=" gtractGraphSearchTracking ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractGuidedTracking:
    """
    title: Guided Tracking
    category: Diffusion.GTRACT
    description: This program will use the Guided Tracking method proposed by Cheng et al. in NeuroImage Volume 31, Issue 3, 1 July 2006, Pages 1075-1085 for finding the tracks in a tensor image.  The method will use a guide fiber as apriori information for the fiber tract position and orientation. If the current eigenvector direction is significantly different from the guide fiber direction at that point, then the guide fiber is used instead of the eigenvector direction. The distance for which the guide fiber has an effect is defined by the user.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputTensorVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputTensorVolume %s",
                    "help_string": "Required: input tensor image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputAnisotropyVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputAnisotropyVolume %s",
                    "help_string": "Required: input anisotropy image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputStartingSeedsLabelMapVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputStartingSeedsLabelMapVolume %s",
                    "help_string": "Required: input starting seeds LabelMap image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "startingSeedsLabel",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--startingSeedsLabel %d",
                    "help_string": "Label value for Starting Seeds",
                },
            ),
        ),
        (
            "inputEndingSeedsLabelMapVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputEndingSeedsLabelMapVolume %s",
                    "help_string": "Required: input ending seeds LabelMap image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "endingSeedsLabel",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--endingSeedsLabel %d",
                    "help_string": "Label value for Ending Seeds",
                },
            ),
        ),
        (
            "inputTract",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputTract %s",
                    "help_string": "Required: guide fiber in vtkPolydata file containing one tract line.",
                    "exists": "True",
                },
            ),
        ),
        (
            "outputTract",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputTract %s",
                    "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them.",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "writeXMLPolyDataFile",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--writeXMLPolyDataFile ",
                    "help_string": "Flag to make use of the XML format for vtkPolyData fiber tracts.",
                },
            ),
        ),
        (
            "seedThreshold",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--seedThreshold %f",
                    "help_string": "Anisotropy threshold for seed selection",
                },
            ),
        ),
        (
            "trackingThreshold",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--trackingThreshold %f",
                    "help_string": "Anisotropy threshold for fiber tracking",
                },
            ),
        ),
        (
            "maximumGuideDistance",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--maximumGuideDistance %f",
                    "help_string": "Maximum distance for using the guide fiber direction",
                },
            ),
        ),
        (
            "curvatureThreshold",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--curvatureThreshold %f",
                    "help_string": "Curvature threshold (Degrees)",
                },
            ),
        ),
        (
            "guidedCurvatureThreshold",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--guidedCurvatureThreshold %f",
                    "help_string": "Guided Curvature Threshold (Degrees)",
                },
            ),
        ),
        (
            "minimumLength",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--minimumLength %f",
                    "help_string": "Minimum fiber length. Helpful for filtering invalid tracts.",
                },
            ),
        ),
        (
            "maximumLength",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--maximumLength %f",
                    "help_string": "Maximum fiber length",
                },
            ),
        ),
        (
            "stepSize",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--stepSize %f",
                    "help_string": "Fiber tracking step size",
                },
            ),
        ),
        (
            "useLoopDetection",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--useLoopDetection ",
                    "help_string": "Flag to make use of loop detection.",
                },
            ),
        ),
        (
            "useTend",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--useTend ",
                    "help_string": "Flag to make use of Tend F and Tend G parameters.",
                },
            ),
        ),
        (
            "tendF",
            attr.ib(
                type=traits.Float,
                metadata={"argstr": "--tendF %f", "help_string": "Tend F parameter"},
            ),
        ),
        (
            "tendG",
            attr.ib(
                type=traits.Float,
                metadata={"argstr": "--tendG %f", "help_string": "Tend G parameter"},
            ),
        ),
    ]
    output_fields = [
        (
            "outputTract",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them.",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractGuidedTracking",
        executable=" gtractGuidedTracking ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractImageConformity:
    """
    title: Image Conformity
    category: Diffusion.GTRACT
    description: This program will straighten out the Direction and Origin to match the Reference Image.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputVolume %s",
                    "help_string": "Required: input file containing the signed short image to reorient without resampling.",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputReferenceVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputReferenceVolume %s",
                    "help_string": "Required: input file containing the standard image to clone the characteristics of.",
                    "exists": "True",
                },
            ),
        ),
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputVolume %s",
                    "help_string": "Required: name of output Nrrd or Nifti file containing the reoriented image in reference image space.",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: name of output Nrrd or Nifti file containing the reoriented image in reference image space.",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractImageConformity",
        executable=" gtractImageConformity ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractInvertBSplineTransform:
    """
    title: B-Spline Transform Inversion
    category: Diffusion.GTRACT
    description: This program will invert a B-Spline transform using a thin-plate spline approximation.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputReferenceVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputReferenceVolume %s",
                    "help_string": "Required: input image file name to exemplify the anatomical space to interpolate over.",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputTransform",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputTransform %s",
                    "help_string": "Required: input B-Spline transform file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "outputTransform",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputTransform %s",
                    "help_string": "Required: output transform file name",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "landmarkDensity",
            attr.ib(
                type=InputMultiPath,
                metadata={
                    "argstr": "--landmarkDensity %s",
                    "help_string": "Number of landmark subdivisions in all 3 directions",
                    "sep": ",",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputTransform",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: output transform file name",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractInvertBSplineTransform",
        executable=" gtractInvertBSplineTransform ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractInvertDisplacementField:
    """
    title: Invert Displacement Field
    category: Diffusion.GTRACT
    description: This program will invert a deformatrion field. The size of the deformation field is defined by an example image provided by the user
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "baseImage",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--baseImage %s",
                    "help_string": "Required: base image used to define the size of the inverse field",
                    "exists": "True",
                },
            ),
        ),
        (
            "deformationImage",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--deformationImage %s",
                    "help_string": "Required: Displacement field image",
                    "exists": "True",
                },
            ),
        ),
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputVolume %s",
                    "help_string": "Required: Output deformation field",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "subsamplingFactor",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--subsamplingFactor %d",
                    "help_string": "Subsampling factor for the deformation field",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: Output deformation field",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractInvertDisplacementField",
        executable=" gtractInvertDisplacementField ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractInvertRigidTransform:
    """
    title: Rigid Transform Inversion
    category: Diffusion.GTRACT
    description: This program will invert a Rigid transform.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputTransform",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputTransform %s",
                    "help_string": "Required: input rigid transform file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "outputTransform",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputTransform %s",
                    "help_string": "Required: output transform file name",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputTransform",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: output transform file name",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractInvertRigidTransform",
        executable=" gtractInvertRigidTransform ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractResampleAnisotropy:
    """
    title: Resample Anisotropy
    category: Diffusion.GTRACT
    description: This program will resample a floating point image using either the Rigid or B-Spline transform. You may want to save the aligned B0 image after each of the anisotropy map co-registration steps with the anatomical image to check the registration quality with another tool.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputAnisotropyVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputAnisotropyVolume %s",
                    "help_string": "Required: input file containing the anisotropy image",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputAnatomicalVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputAnatomicalVolume %s",
                    "help_string": "Required: input file containing the anatomical image whose characteristics will be cloned.",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputTransform",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputTransform %s",
                    "help_string": "Required: input Rigid OR Bspline transform file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "transformType",
            attr.ib(
                type=traits.Enum,
                metadata={
                    "argstr": "--transformType %s",
                    "help_string": "Transform type: Rigid, B-Spline",
                },
            ),
        ),
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputVolume %s",
                    "help_string": "Required: name of output NRRD file containing the resampled transformed anisotropy image.",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: name of output NRRD file containing the resampled transformed anisotropy image.",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractResampleAnisotropy",
        executable=" gtractResampleAnisotropy ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractResampleB0:
    """
    title: Resample B0
    category: Diffusion.GTRACT
    description: This program will resample a signed short image using either a Rigid or B-Spline transform. The user must specify a template image that will be used to define the origin, orientation, spacing, and size of the resampled image.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputVolume %s",
                    "help_string": "Required: input file containing the 4D image",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputAnatomicalVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputAnatomicalVolume %s",
                    "help_string": "Required: input file containing the anatomical image defining the origin, spacing and size of the resampled image (template)",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputTransform",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputTransform %s",
                    "help_string": "Required: input Rigid OR Bspline transform file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "vectorIndex",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--vectorIndex %d",
                    "help_string": "Index in the diffusion weighted image set for the B0 image",
                },
            ),
        ),
        (
            "transformType",
            attr.ib(
                type=traits.Enum,
                metadata={
                    "argstr": "--transformType %s",
                    "help_string": "Transform type: Rigid, B-Spline",
                },
            ),
        ),
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputVolume %s",
                    "help_string": "Required: name of output NRRD file containing the resampled input image.",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: name of output NRRD file containing the resampled input image.",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractResampleB0",
        executable=" gtractResampleB0 ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractResampleCodeImage:
    """
    title: Resample Code Image
    category: Diffusion.GTRACT
    description: This program will resample a short integer code image using either the Rigid or Inverse-B-Spline transform.  The reference image is the DTI tensor anisotropy image space, and the input code image is in anatomical space.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputCodeVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputCodeVolume %s",
                    "help_string": "Required: input file containing the code image",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputReferenceVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputReferenceVolume %s",
                    "help_string": "Required: input file containing the standard image to clone the characteristics of.",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputTransform",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputTransform %s",
                    "help_string": "Required: input Rigid or Inverse-B-Spline transform file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "transformType",
            attr.ib(
                type=traits.Enum,
                metadata={
                    "argstr": "--transformType %s",
                    "help_string": "Transform type: Rigid or Inverse-B-Spline",
                },
            ),
        ),
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputVolume %s",
                    "help_string": "Required: name of output NRRD file containing the resampled code image in acquisition space.",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: name of output NRRD file containing the resampled code image in acquisition space.",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractResampleCodeImage",
        executable=" gtractResampleCodeImage ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractResampleDWIInPlace:
    """
    title: Resample DWI In Place
    category: Diffusion.GTRACT
    description: Resamples DWI image to structural image.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta, Greg Harris, Hans Johnson, and Joy Matsui.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputVolume %s",
                    "help_string": "Required: input image is a 4D NRRD image.",
                    "exists": "True",
                },
            ),
        ),
        (
            "referenceVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--referenceVolume %s",
                    "help_string": "If provided, resample to the final space of the referenceVolume 3D data set.",
                    "exists": "True",
                },
            ),
        ),
        (
            "outputResampledB0",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputResampledB0 %s",
                    "help_string": "Convenience function for extracting the first index location (assumed to be the B0)",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "inputTransform",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputTransform %s",
                    "help_string": "Required: transform file derived from rigid registration of b0 image to reference structural image.",
                    "exists": "True",
                },
            ),
        ),
        (
            "warpDWITransform",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--warpDWITransform %s",
                    "help_string": "Optional: transform file to warp gradient volumes.",
                    "exists": "True",
                },
            ),
        ),
        (
            "debugLevel",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--debugLevel %d",
                    "help_string": "Display debug messages, and produce debug intermediate results.  0=OFF, 1=Minimal, 10=Maximum debugging.",
                },
            ),
        ),
        (
            "writeOutputMetaData",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--writeOutputMetaData %s",
                    "help_string": "A file to write the output image diffusion gradient directions in a CSV file",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "imageOutputSize",
            attr.ib(
                type=InputMultiPath,
                metadata={
                    "argstr": "--imageOutputSize %s",
                    "help_string": "The voxel lattice for the output image, padding is added if necessary. NOTE: if 0,0,0, then the inputVolume size is used.",
                    "sep": ",",
                },
            ),
        ),
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputVolume %s",
                    "help_string": "Required: output image (NRRD file) that has been rigidly transformed into the space of the structural image and padded if image padding was changed from 0,0,0 default.",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputResampledB0",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Convenience function for extracting the first index location (assumed to be the B0)",
                    "exists": "True",
                },
            ),
        ),
        (
            "writeOutputMetaData",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "A file to write the output image diffusion gradient directions in a CSV file",
                    "exists": "True",
                },
            ),
        ),
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: output image (NRRD file) that has been rigidly transformed into the space of the structural image and padded if image padding was changed from 0,0,0 default.",
                    "exists": "True",
                },
            ),
        ),
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractResampleDWIInPlace",
        executable=" gtractResampleDWIInPlace ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractResampleFibers:
    """
    title: Resample Fibers
    category: Diffusion.GTRACT
    description: This program will resample a fiber tract with respect to a pair of deformation fields that represent the forward and reverse deformation fields.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputForwardDeformationFieldVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputForwardDeformationFieldVolume %s",
                    "help_string": "Required: input forward deformation field image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputReverseDeformationFieldVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputReverseDeformationFieldVolume %s",
                    "help_string": "Required: input reverse deformation field image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputTract",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputTract %s",
                    "help_string": "Required: name of input vtkPolydata file containing tract lines.",
                    "exists": "True",
                },
            ),
        ),
        (
            "outputTract",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputTract %s",
                    "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them.",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "writeXMLPolyDataFile",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--writeXMLPolyDataFile ",
                    "help_string": "Flag to make use of the XML format for vtkPolyData fiber tracts.",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputTract",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them.",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractResampleFibers",
        executable=" gtractResampleFibers ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractStreamlineTracking:
    """
    title: Streamline Tracking
    category: Diffusion.GTRACT
    description: This program create fiber tracts in a tensor image using a basic streamlines algorithm.  The algorithm requires a starting and ending region to be be defined for the fiber tracts. Only those that reach the ending region without terminating are kept. Criteria for termination include length, anisotropy, and curvature. These can be controlled by user. In addition, the TEND method as proposed by Lazar et al Human Brain Mapping 18:306-321(2003) has been instrumented.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputTensorVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputTensorVolume %s",
                    "help_string": "Required: input tensor image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputAnisotropyVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputAnisotropyVolume %s",
                    "help_string": "Required: input anisotropy image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputStartingSeedsLabelMapVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputStartingSeedsLabelMapVolume %s",
                    "help_string": "Required: input starting seeds LabelMap image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "startingSeedsLabel",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--startingSeedsLabel %d",
                    "help_string": "Label value for Starting Seeds",
                },
            ),
        ),
        (
            "inputEndingSeedsLabelMapVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputEndingSeedsLabelMapVolume %s",
                    "help_string": "Required: input ending seeds LabelMap image file name",
                    "exists": "True",
                },
            ),
        ),
        (
            "endingSeedsLabel",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--endingSeedsLabel %d",
                    "help_string": "Label value for Ending Seeds",
                },
            ),
        ),
        (
            "outputTract",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputTract %s",
                    "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them.",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "writeXMLPolyDataFile",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--writeXMLPolyDataFile ",
                    "help_string": "Flag to make use of the XML format for vtkPolyData fiber tracts.",
                },
            ),
        ),
        (
            "seedThreshold",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--seedThreshold %f",
                    "help_string": "Anisotropy threshold for seed selection",
                },
            ),
        ),
        (
            "trackingThreshold",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--trackingThreshold %f",
                    "help_string": "Anisotropy threshold for fiber tracking",
                },
            ),
        ),
        (
            "curvatureThreshold",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--curvatureThreshold %f",
                    "help_string": "Curvature threshold (Degrees)",
                },
            ),
        ),
        (
            "minimumLength",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--minimumLength %f",
                    "help_string": "Minimum fiber length. Helpful for filtering invalid tracts.",
                },
            ),
        ),
        (
            "maximumLength",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--maximumLength %f",
                    "help_string": "Maximum fiber length",
                },
            ),
        ),
        (
            "stepSize",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--stepSize %f",
                    "help_string": "Fiber tracking step size",
                },
            ),
        ),
        (
            "useLoopDetection",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--useLoopDetection ",
                    "help_string": "Flag to make use of loop detection.",
                },
            ),
        ),
        (
            "useTend",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--useTend ",
                    "help_string": "Flag to make use of Tend F and Tend G parameters.",
                },
            ),
        ),
        (
            "tendF",
            attr.ib(
                type=traits.Float,
                metadata={"argstr": "--tendF %f", "help_string": "Tend F parameter"},
            ),
        ),
        (
            "tendG",
            attr.ib(
                type=traits.Float,
                metadata={"argstr": "--tendG %f", "help_string": "Tend G parameter"},
            ),
        ),
    ]
    output_fields = [
        (
            "outputTract",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them.",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractStreamlineTracking",
        executable=" gtractStreamlineTracking ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractTensor:
    """
    title: Tensor Estimation
    category: Diffusion.GTRACT
    description: This step will convert a b-value averaged diffusion tensor image to a 3x3 tensor voxel image. This step takes the diffusion tensor image data and generates a tensor representation of the data based on the signal intensity decay, b values applied, and the diffusion difrections. The apparent diffusion coefficient for a given orientation is computed on a pixel-by-pixel basis by fitting the image data (voxel intensities) to the Stejskal-Tanner equation. If at least 6 diffusion directions are used, then the diffusion tensor can be computed. This program uses itk::DiffusionTensor3DReconstructionImageFilter. The user can adjust background threshold, median filter, and isotropic resampling.
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta and Greg Harris.
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputVolume %s",
                    "help_string": "Required: input image 4D NRRD image. Must contain data based on at least 6 distinct diffusion directions. The inputVolume is allowed to have multiple b0 and gradient direction images. Averaging of the b0 image is done internally in this step. Prior averaging of the DWIs is not required.",
                    "exists": "True",
                },
            ),
        ),
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputVolume %s",
                    "help_string": "Required: name of output NRRD file containing the Tensor vector image",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "medianFilterSize",
            attr.ib(
                type=InputMultiPath,
                metadata={
                    "argstr": "--medianFilterSize %s",
                    "help_string": "Median filter radius in all 3 directions",
                    "sep": ",",
                },
            ),
        ),
        (
            "maskProcessingMode",
            attr.ib(
                type=traits.Enum,
                metadata={
                    "argstr": "--maskProcessingMode %s",
                    "help_string": "ROIAUTO:  mask is implicitly defined using a otsu forground and hole filling algorithm. ROI: Uses the masks to define what parts of the image should be used for computing the transform. NOMASK: no mask used",
                },
            ),
        ),
        (
            "maskVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--maskVolume %s",
                    "help_string": "Mask Image, if maskProcessingMode is ROI",
                    "exists": "True",
                },
            ),
        ),
        (
            "backgroundSuppressingThreshold",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--backgroundSuppressingThreshold %d",
                    "help_string": "Image threshold to suppress background. This sets a threshold used on the b0 image to remove background voxels from processing. Typically, values of 100 and 500 work well for Siemens and GE DTI data, respectively. Check your data particularly in the globus pallidus to make sure the brain tissue is not being eliminated with this threshold.",
                },
            ),
        ),
        (
            "resampleIsotropic",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--resampleIsotropic ",
                    "help_string": "Flag to resample to isotropic voxels. Enabling this feature is recommended if fiber tracking will be performed.",
                },
            ),
        ),
        (
            "size",
            attr.ib(
                type=traits.Float,
                metadata={
                    "argstr": "--size %f",
                    "help_string": "Isotropic voxel size to resample to",
                },
            ),
        ),
        (
            "b0Index",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--b0Index %d",
                    "help_string": "Index in input vector index to extract",
                },
            ),
        ),
        (
            "applyMeasurementFrame",
            attr.ib(
                type=traits.Bool,
                metadata={
                    "argstr": "--applyMeasurementFrame ",
                    "help_string": "Flag to apply the measurement frame to the gradient directions",
                },
            ),
        ),
        (
            "ignoreIndex",
            attr.ib(
                type=InputMultiPath,
                metadata={
                    "argstr": "--ignoreIndex %s",
                    "help_string": "Ignore diffusion gradient index. Used to remove specific gradient directions with artifacts.",
                    "sep": ",",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputVolume",
            attr.ib(
                type=File,
                metadata={
                    "help_string": "Required: name of output NRRD file containing the Tensor vector image",
                    "exists": "True",
                },
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractTensor",
        executable=" gtractTensor ",
        input_spec=input_spec,
        output_spec=output_spec,
    )


class gtractTransformToDisplacementField:
    """
    title: Create Displacement Field
    category: Diffusion.GTRACT
    description: This program will compute forward deformation from the given Transform. The size of the DF is equal to MNI space
    version: 5.2.0
    documentation-url: http://wiki.slicer.org/slicerWiki/index.php/Modules:GTRACT
    license: http://mri.radiology.uiowa.edu/copyright/GTRACT-Copyright.txt
    contributor: This tool was developed by Vincent Magnotta, Madhura Ingalhalikar, and Greg Harris
    acknowledgements: Funding for this version of the GTRACT program was provided by NIH/NINDS R01NS050568-01A2S1
    """

    input_fields = [
        (
            "inputTransform",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputTransform %s",
                    "help_string": "Input Transform File Name",
                    "exists": "True",
                },
            ),
        ),
        (
            "inputReferenceVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--inputReferenceVolume %s",
                    "help_string": "Required: input image file name to exemplify the anatomical space over which to vcl_express the transform as a displacement field.",
                    "exists": "True",
                },
            ),
        ),
        (
            "outputDeformationFieldVolume",
            attr.ib(
                type=File,
                metadata={
                    "argstr": "--outputDeformationFieldVolume %s",
                    "help_string": "Output deformation field",
                    "hash_files": "False",
                },
            ),
        ),
        (
            "numberOfThreads",
            attr.ib(
                type=traits.Int,
                metadata={
                    "argstr": "--numberOfThreads %d",
                    "help_string": "Explicitly specify the maximum number of threads to use.",
                },
            ),
        ),
    ]
    output_fields = [
        (
            "outputDeformationFieldVolume",
            attr.ib(
                type=File,
                metadata={"help_string": "Output deformation field", "exists": "True"},
            ),
        )
    ]

    input_spec = SpecInfo(name="Input", fields=input_fields, bases=(ShellSpec,))
    output_spec = SpecInfo(name="Output", fields=output_fields, bases=(ShellSpec,))

    task = ShellCommandTask(
        name="gtractTransformToDisplacementField",
        executable=" gtractTransformToDisplacementField ",
        input_spec=input_spec,
        output_spec=output_spec,
    )
